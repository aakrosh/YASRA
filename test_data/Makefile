#for a full scale assisted assembly:
#  keep files $(READS) Makefile and reference.fa in this directory, change the
#  values of the variables C, READS and then type:
#
#  make TYPE= ORIENT= PID= &> Summary
#  
#  The choices for TYPE are '454' and 'solexa'. '454' refers to reads from 454
#  technology which are more than 150 bp long. 'solexa' refers to short reads
#  which are expected to be less than 50 bps.
#	
#  The choices for ORIENT are 'linear' and 'circular'. It refers to the 
#  orientation of the reference genome. (example: mtDNA would be circular)
#
# The choices for PID are:
# 
# --for 454 reads:
#    'same'       : about 98% identity
#    'high'       : about 95% identity
#    'medium      : about 90% identity
#    'low'        : about 85% identity
#    'verylow'    : about 75% identity
#    'desperate'  : really low scores, because we are despeate (rather slow)
#
# --for solexa reads:
#	'same'        : about 95% identity
#	'medium'      : about 85% identity
#	'desperate'   : low scores, as we are desperate :) (rather slow)
#
# This mode of assembly is rather slow because we try to walk through the small
# gaps and close the contigs. However, if we want to ignore the gaps and want
# quicker results (and this is the mode I would advise most of the time) is by
# typing:
#
#  make single_step TYPE= ORIENT= PID= &> Summary
#
# Final output of the process is the file 'Final_Assembly' which is the fasta
# file of contigs. 'Assembly.qual' which details the base profile for each of 
# the positions in the consensus sequence. A section in this
# file is like:
#
# Contig 3
# .
# .
# .
#
# 302     C       0       181     0       0       0       181
# .
# .
#
# where the depicted line shows the base profile for the position 302 in Contig
# 3. 
# The line is to be read as follows:
# "Base Position" "Consensus Base" "Number of reads supporting 'A'" "Number of
# reads supporting 'C'" "Number of reads supporting 'G'" "Number of reads
# supporting 'T'" "Number of reads supporting a gap" "Total coverage at that
# base" 
#
# Another file Amb.txt is generated which lists the positions the assembler is
# not sure about. Contigs.ace is an ace file which is generated by the
# assembler. Use 'toAmos' to convert it to a format which can be viewed using
# Hawkeye. I have not tested it with Consed.
#
# Running 
#
# make subs 
# creates a file of differences between the target genome and the reference
# genome and gives some statistics about them.
#
# For more information regarding options and tools in YASRA please contact :
# 
# ratan@bx.psu.edu
#

#this needs to be changed to point to the directory with the binaries.
C=./../../bin

#this is the file of reads to be used for the assembly
READS=454.fa

#this is a soft link/file which is to be used as a template
TEMPLATE=reference.fa

#this is the length of the ids of the reads. 
WL=`cat $(READS) | grep '>' | awk '{print $$1}' | wc -L`

#is this 454 or solexa data
TYPE=454

#is this a circular or a linear genome
ORIENT=linear

#maximum length of a read
MAX=`cat $(READS) | awk '{if(substr($$0,1,1) == ">"){if(a>max){max=a}; a=0} else{a = a+length($$0)}}; END{print max}'`

# Q gives parameters for finding weak matches to a rather distant species
# R gives parameters for finding high-identity matches to endogenous DNA

ifeq ($(TYPE), 454)
	MAKE_TEMPLATE=min=150
	ifeq ($(PID),same)
		Q=--yasra98
	endif
	ifeq ($(PID),high)
		Q=--yasra95
	endif
	ifeq ($(PID),medium)
		Q=--yasra90
	endif
	ifeq ($(PID), low)
		Q=--yasra85
	endif
	ifeq ($(PID), verylow)
		Q=--yasra75
	endif
	ifeq ($(PID), desperate)
		Q=Y=2000 K=2200 L=3000
	endif
	R=--yasra98 
endif

ifeq ($(TYPE), solexa)
	MAKE_TEMPLATE=N=100 min=30
	SOLEXA_INSERT=N=100
	SOLEXA=-solexa
	ifeq ($(PID),same)
		Q=--yasra95short
	endif
	ifeq ($(PID),medium)
		Q=--yasra85short
	endif
	ifeq ($(PID), desperate)
		Q=T=0 W=7 K=1200 L=1400
	endif
	R=--yasra95short 
endif

ifeq ($(ORIENT), circular)
	CIRCULAR=-circular
endif

TOOLS=./..
COMPARE=$(TEMPLATE)

CON_INFO=info.txt
REJECT=hits_reject.fa
REJ=Rejects.txt
REP=repeats.txt
HITS=hits_final.fa

all:step1 step2 step3 step4 step5

single_step:
	make final_assembly T=$(TEMPLATE) V=60 P="$Q" I=70 S="-sig=1"
	rm MAlign ReMAlign

step1 :
	#Assemble on the original template:
	make assemble_hits T=$(TEMPLATE) V=60 I=70 P="$Q" N=1

step2:
	touch fake.txt 
	$C/finisher $(REJ) $(REP)
	@rm Assembly* hits* template[0-9]* $(REP) fake.txt

step3:
	#Determine difference between reads and assembly:
	lastz template $(READS) $R | \
	$C/lav_processor | \
	$C/template_hits template $(READS) cov=70 pct=90 stats \
	   discard=$(REJECT) > read_hits
	make plot H=read_hits

step4:
	#Trim Assembly:
	if [ -s plot_rejects.eps ]; then \
		mv plot_rejects.eps old_plot_rejects.eps; \
	fi
	$C/trim_assembly template read_hits $(REJECT) min=1 > AssemblyX
	$C/make_template AssemblyX noends $(MAKE_TEMPLATE) info=$(CON_INFO) \
		> ftemplate
	make assemble_hits T=ftemplate V=70 I=90 P="$R" N=Y
	$C/make_template AssemblyY noends $(MAKE_TEMPLATE) info=$(CON_INFO) \
		> final_template
	lastz final_template $(READS) $R | \
	$C/lav_processor | \
	$C/template_hits final_template $(READS) cov=70 pct=90 stats \
	   discard=$(REJECT) > read_hits
	make plot H=read_hits
	@rm read_hits AssemblyX AssemblyY ftemplate Assembly_ftemplate \
		hits_ftemplate.fa

step5:
	make final_assembly T=final_template V=70 P="$R" I=90 S="-sig=1"
	@rm final_template template MAlign ReMAlign

final_assembly:
	time lastz $T $(READS) $P | \
	time $C/lav_processor $S  | \
	time $C/template_hits $T $(READS) cov=$V pct=$I \
		discard=$(REJECT)  > $(HITS)
	cat $(HITS) | grep '>Hit' | awk '{print $$4, $$1}' | sort -n |  \
		uniq -w $(WL) -D | awk '{print $$2}' > $(REP)
	time $C/assembler hits_final.fa -ace=Contigs.ace -rejects=$(REJ) \
		-repeats=$(REP) $(SOLEXA) -max_length=$(MAX) > MAlign
	time $C/realigner -ace=Contigs.ace < MAlign > ReMAlign
	time $C/consense -ace=Contigs.ace -amb=Amb.txt -profile=Assembly.qual \
	 < ReMAlign > Final_Assembly

plot:
	make -f $(TOOLS)/tools.mk rejects H=$H R=$(REJECT) C=$(CON_INFO);

stepx:
	#Assemble on the endogenous contigs:
	cp fake.txt $(CON_INFO)
	$C/make_template Assembly$W info=fake.txt $(MAKE_TEMPLATE)> template$X
	make assemble_hits T=template$X V=70 P="$R" I=90 N=$X


assemble_hits : 
	time lastz $T $(READS) $P | \
	$C/lav_processor  | \
	$C/template_hits $T $(READS) cov=$V pct=$I discard=$(REJECT) \
		stats > hits_$T.fa
	time make assemble HITS=hits_$T.fa
	$C/welder Assembly_$T $(CIRCULAR) $(SOLEXA) | $C/consense > Assembly$N

assemble:
	cat $(HITS) | grep '>Hit' | awk '{print $$4, $$1}' | sort -n |  \
		uniq -w $(WL) -D | awk '{print $$2}' > $(REP)
	$C/assembler $(HITS) -repeats=$(REP) $(SOLEXA) \
		-rejects=$(REJ) -max_length=$(MAX) | \
	$C/realigner > ReMAlign
	$C/consense -amb=Amb.txt -profile=Assembly.qual \
	    < ReMAlign > Assembly_$T


subs:
	lastz $(COMPARE) Final_Assembly B=0 --identity=95..100 > fake.bz
	$C/substitutions fake.bz $(COMPARE) Final_Assembly substitutions gaps \
		> subs.txt


clean:
	rm -r `ls -1 | grep -v "Makefile\|$(READS)\|reference.fa\|README"`
